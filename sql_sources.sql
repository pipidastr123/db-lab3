CREATE OR REPLACE FUNCTION public.create_tables()
    RETURNS void
    language 'sql'
    
AS $BODY$ 
CREATE TABLE IF NOT EXISTS public.consumers(
  id int NOT NULL GENERATED BY DEFAULT AS IDENTITY,
  name text NOT NULL,
  address text,
  primary key (id)
);

CREATE TABLE IF NOT EXISTS public.details(
  id int NOT NULL GENERATED BY DEFAULT AS IDENTITY,
  name varchar(100) NOT NULL,
  cost int NOT NULL,
  
  primary key (id)
);

CREATE TABLE IF NOT EXISTS public.orders_prices(
  id int NOT NULL GENERATED BY DEFAULT AS IDENTITY,
  price int,

  primary key (id)
);

CREATE INDEX IF NOT EXISTS detail_name on details (name);

CREATE TABLE IF NOT EXISTS public.orders(
  id int NOT NULL GENERATED BY DEFAULT AS IDENTITY,
  purchase_date timestamp NOT NULL DEFAULT current_timestamp,
  consumer_id int NOT NULL,
  --dealer_id int NOT NULL,
  detail_id int NOT NULL,
  quantity int NOT NULL,
  -- price int,
  
  primary key (id),
  -- UNIQUE (id),
  
  -- FOREIGN KEY (id) REFERENCES orders_prices (id) ON UPDATE CASCADE  ON DELETE CASCADE,
  FOREIGN KEY (consumer_id) REFERENCES consumers (id) ON UPDATE CASCADE,
  FOREIGN KEY (detail_id) REFERENCES details (id) ON UPDATE CASCADE
); 
$BODY$;

select create_tables();

CREATE OR REPLACE FUNCTION calc_new_price() 
RETURNS TRIGGER AS
$$ BEGIN
  -- NEW.price = (select d.cost FROM details d WHERE d.id = NEW.detail_id) 
                                                            -- * NEW.quantity;
  INSERT INTO orders_prices VALUES (NEW.id, (SELECT d.cost FROM details d WHERE d.id = NEW.detail_id) * NEW.quantity);
  RETURN NEW;
END $$ language 'plpgsql';

CREATE OR REPLACE FUNCTION update_price()
RETURNS TRIGGER AS
$$ BEGIN
  UPDATE orders_prices SET price = (select d.cost FROM details d WHERE d.id = NEW.detail_id) * NEW.quantity;
  RETURN NEW;
END $$ language 'plpgsql';


DROP TRIGGER IF EXISTS update_orders_prices ON orders;

CREATE TRIGGER update_orders_prices AFTER UPDATE
  ON orders FOR EACH ROW EXECUTE PROCEDURE update_price();

DROP TRIGGER IF EXISTS calc_price_for_new_record ON orders;

CREATE TRIGGER calc_price_for_new_record BEFORE INSERT  
  ON orders FOR EACH ROW EXECUTE PROCEDURE calc_new_price();



CREATE OR REPLACE FUNCTION update_prices_after_detail_upd()
RETURNS TRIGGER AS
$$ BEGIN
  UPDATE orders_prices SET price = NEW.cost * (SELECT o.quantity FROM orders o WHERE o.detail_id = NEW.id);
  RETURN NEW;
END $$ language 'plpgsql';


DROP TRIGGER IF EXISTS update_orders_prices_after_detail_update ON details;

CREATE TRIGGER update_orders_prices_after_detail_update BEFORE UPDATE
  ON details FOR EACH ROW EXECUTE PROCEDURE update_prices_after_detail_upd();


CREATE OR REPLACE FUNCTION delete_price()
RETURNS TRIGGER AS
$$ BEGIN
  DELETE from orders_prices op WHERE op.id = OLD.id;
  RETURN OLD;
END $$ language 'plpgsql';

DROP TRIGGER IF EXISTS delete_price_after_order_deleted ON orders;

CREATE TRIGGER delete_price_after_order_deleted AFTER DELETE ON orders
  FOR EACH ROW EXECUTE PROCEDURE delete_price();
  
  
  
CREATE OR REPLACE FUNCTION get_consumers() 
RETURNS table(id int, name text, address text) AS
$$ BEGIN
  RETURN QUERY SELECT c.id , c.name , c.address FROM consumers c;
END $$ language 'plpgsql';



CREATE OR REPLACE FUNCTION get_details()
RETURNS table(id int, name varchar(100), cost int) AS
$$ BEGIN
  RETURN QUERY SELECT d.id, d.name, d.cost FROM details d;
END $$ language 'plpgsql';



CREATE OR REPLACE FUNCTION get_orders()
RETURNS table(id int, purchase_date timestamp, consumer_id int, detail_id int,
              quantity int, price int) AS
$$ BEGIN
  RETURN QUERY SELECT o.id, o.purchase_date, o.consumer_id, o.detail_id, o.quantity, p.price
                       FROM orders o INNER JOIN orders_prices p ON o.id = p.id;
END $$ language 'plpgsql';



CREATE OR REPLACE FUNCTION public.add_consumer(name text, address text)
RETURNS void AS
$$ BEGIN
  INSERT INTO consumers(name, address) VALUES (name, address);
END $$ language 'plpgsql';




CREATE OR REPLACE FUNCTION public.add_detail(name varchar(100), cost int)
RETURNS void AS
$$ BEGIN
  INSERT INTO details(name, cost) VALUES (name, cost);
END $$ language 'plpgsql';


    
CREATE OR REPLACE FUNCTION public.add_order(consumer_id int, detail_id int, 
                                            purchase_date timestamp, quantity int)
RETURNS void AS
$$ BEGIN
  INSERT INTO orders(purchase_date, consumer_id, detail_id, quantity) VALUES
        (purchase_date, consumer_id, detail_id, quantity);
END $$ language 'plpgsql';



CREATE OR REPLACE FUNCTION public.add_order_default_date(consumer_id int, detail_id int, quantity int)
RETURNS void AS
$$ BEGIN
  INSERT INTO orders(consumer_id, detail_id, quantity) VALUES (consumer_id, detail_id, quantity);
END $$ language 'plpgsql';



CREATE OR REPLACE FUNCTION clear_details()
RETURNS void AS
$$ BEGIN
  TRUNCATE table details;
END $$ language 'plpgsql';



CREATE OR REPLACE FUNCTION clear_consumers()
RETURNS void AS
$$ BEGIN
  TRUNCATE table consumers;
END $$ language 'plpgsql';


CREATE OR REPLACE FUNCTION clear_orders()
RETURNS void AS
$$ BEGIN
  TRUNCATE table orders CASCADE;
END $$ language 'plpgsql';



CREATE OR REPLACE FUNCTION clear_all()
RETURNS void AS
$$ BEGIN
  TRUNCATE table details;
  TRUNCATE table consumers;
  TRUNCATE table orders;
END $$ language 'plpgsql';



CREATE OR REPLACE FUNCTION search_orders(query_text character varying)
RETURNS table(id int, purchase_date timestamp, consumer_id int, detail_id int,
              quantity int, price int) AS
$$ BEGIN
  RETURN QUERY SELECT temp.id, temp.purchase_date, temp.consumer_id, temp.detail_id,
                temp.quantity, temp.price FROM (select o.id, o.purchase_date, o.consumer_id, o.detail_id,
                                                  o.quantity, o.price, d.name FROM orders o INNER JOIN details d
                                                ON d.id = o.detail_id) temp
                                                          INNER JOIN consumers c ON c.id = temp.consumer_id 
                                                WHERE temp.name LIKE CONCAT('%', query_text, '%') 
                                                OR c.name LIKE CONCAT('%', query_text, '%');
END $$ language 'plpgsql';



CREATE OR REPLACE FUNCTION search_details(query_text character varying)
RETURNS table(id int, name varchar(100), cost int) AS
$$ BEGIN
  RETURN QUERY SELECT * FROM details d WHERE d.name LIKE CONCAT('%', query_text, '%');
END $$ language 'plpgsql';



CREATE OR REPLACE FUNCTION search_consumers(query_text character varying)
RETURNS table(id int, name text, address text) AS
$$ BEGIN
  RETURN QUERY SELECT * FROM consumers c WHERE c.name LIKE 
                                          CONCAT('%', query_text, '%');
END $$ language 'plpgsql';



CREATE OR REPLACE FUNCTION delete_order(target_id int)
RETURNS void AS
$$ BEGIN
  delete FROM orders o WHERE o.id = target_id;
END $$ language 'plpgsql';



CREATE OR REPLACE FUNCTION delete_detail(target_id int)
RETURNS void AS
$$ BEGIN
  delete FROM details d WHERE d.id = target_id;
END $$ language 'plpgsql';



CREATE OR REPLACE FUNCTION delete_consumer(target_id int)
RETURNS void AS
$$ BEGIN
  delete FROM consumers c WHERE c.id = target_id;
END $$ language 'plpgsql';



CREATE OR REPLACE FUNCTION update_consumer_name(target_id int, value text)
RETURNS void AS
$$ BEGIN
  UPDATE consumers SET "name" = value WHERE consumers.id = target_id;
END $$ language 'plpgsql';



CREATE OR REPLACE FUNCTION update_consumer_address(target_id int, value text)
RETURNS void AS
$$ BEGIN
  UPDATE consumers SET "address" = value WHERE consumers.id = target_id;
END $$ language 'plpgsql';



CREATE OR REPLACE FUNCTION update_detail_name(target_id int, value varchar(100))
RETURNS void AS
$$ BEGIN
  UPDATE details SET "name" = value WHERE details.id = target_id;
END $$ language 'plpgsql';



CREATE OR REPLACE FUNCTION update_detail_cost(target_id int, value int)
RETURNS void AS
$$ BEGIN
  UPDATE details SET "cost" = value WHERE details.id = target_id;
END $$ language 'plpgsql';



CREATE OR REPLACE FUNCTION update_order_consumer_id(target_id int, value int)
RETURNS void AS 
$$ BEGIN
  UPDATE orders SET "consumer_id" = value WHERE orders.id = target_id;
END $$ language 'plpgsql';



CREATE OR REPLACE FUNCTION update_order_detail_id(target_id int, value int)
RETURNS void AS
$$ BEGIN
  UPDATE orders SET "detail_id" = value WHERE orders.id = target_id;
END $$ language 'plpgsql';



CREATE OR REPLACE FUNCTION update_order_quantity(target_id int, value int)
RETURNS void AS
$$ BEGIN
  UPDATE orders SET "quantity" = value WHERE orders.id = target_id;
END $$ language 'plpgsql';

